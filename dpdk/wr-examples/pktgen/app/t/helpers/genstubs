#!/usr/bin/env perl

# Generate definitions for all fuctions declared with extern in the header
# files that are specified with the STUB directive.
# The generated functions are defined with weak linking semantics, so they
# won't conflict when implemented in an object file that is linked.

use feature "switch";


die "Usage: $0 <sourcefile> <stubfile>\n" .
    "\tRead C <sourcefile>, get all files referred in a STUB: directive " .
    "and generate weakly linked 'empty' functions.\n"
    unless (@ARGV == 2);

my ($src_fn, $out_fn) = @ARGV;


my $stub_header = <<EOF;
/* Stub file, automatically generated by $0.
 * Command line:
 *  $0 @ARGV
 *
 * This file will be automatically regenerated by the Makefile. Manual changes
 * will be lost.
 */
EOF

my $stub_footer = <<EOF;
/* End of auto-generated function stubs */
EOF

open my $in_fh,  '<', $src_fn or die "Could not open $src_fn for reading\n";
my @headers;
while (<$in_fh>) {
    chomp;

    if (/\bSTUB\b/) {
        # Remove keyword and trailing punctuation/whitespace.
        s/^.+STUB\W+//;

        push @headers, split /\s+/;
    }
}
close $in_fh;


open my $out_fh, '>', $out_fn or die "Could not open $out_fn for writing\n";
print $out_fh $stub_header, "\n";
print $out_fh "#include \"$_\"\n" for @headers;     # needed for non-primitive parameter/return type declarations
print $out_fh "\n";

for my $header (@headers) {
    print $out_fh "/*** Stubs for $header ***/\n";

    open($in_fh, '<', $header)
        or open ($in_fh, '<', '../' . $header)
        or die "Could not open $header for reading\n";

READ_HEADER:
    while (<$in_fh>) {
        chomp;

        next unless /^\s*extern\s+/;

        #handle multi-line declarations
        $line = $_;
        while ($line !~ /;/) {
            $_ = <$in_fh>;
            chomp;
            $line .= $_;

            last READ_HEADER if eof;
        }
        $_ = $line;

        # Variables can also be declared with external linkage. Only extern
        # functions need to be stubbed out.
        next unless /^\s*extern\s+(?<ret_type>[\w\d\s_*]+[\w\d_*]+)\s+(?<func_name>[^(]+)(?<func_params>\([^;]+);\s*$/;

        print $out_fh "$+{ret_type} __attribute__ ((weak)) $+{func_name} $+{func_params} { ";
        print $out_fh "note(\"STUB called: $header: $+{func_name}()\"); ";
        print $out_fh "return ";
        given ($+{ret_type}) {
            when ("void") { break; }
            when (/\*$/)  { print $out_fh 'NULL'; }
            when ('int')  { print $out_fh '0'; }
            default       { die "Don't know what value to return for type '$_' (line was [$line])\n"; }
        }
        print $out_fh "; }\n";
    }
    close $in_fh;

    print $out_fh "\n";
}

print $out_fh $stub_footer;

close $out_fh;
